<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>äº’åŠ¨å°è¯´é˜…è¯»å™¨</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* è‡ªå®šä¹‰æ ·å¼ */
        body, html {
            overscroll-behavior: none; /* é˜²æ­¢ç§»åŠ¨ç«¯ä¸‹æ‹‰åˆ·æ–° */
        }
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .safe-area-pb {
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        /* åŠ¨ç”»å…³é”®å¸§æ¨¡æ‹Ÿ */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .animate-in {
            animation: fadeIn 0.2s ease-out forwards;
        }
        @keyframes slideInFromTop {
            from { transform: translateY(-0.5rem); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .slide-in-from-top-2 {
            animation: slideInFromTop 0.2s ease-out forwards;
        }
        @keyframes zoomIn {
            from { transform: scale(0.95); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        .zoom-in-95 {
            animation: zoomIn 0.2s ease-out forwards;
        }
    </style>
</head>
<body class="bg-gray-900 text-base antialiased">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- å›¾æ ‡ç»„ä»¶ (æ›¿æ¢ lucide-react) ---
        const MoreHorizontal = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/></svg>
        );
        const RotateCcw = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"/><path d="M3 3v9h9"/></svg>
        );
        const Upload = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
        );

        // --- æ ¸å¿ƒé€»è¾‘ ---

        // è§£æè„šæœ¬å·¥å…·å‡½æ•°
        const parseScript = (text) => {
            const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l);
            const data = { scenes: {}, branches: {}, startSceneId: null };
            
            let currentBlockId = null;
            let currentBlockType = null; // 'scene' | 'branch'
            let currentLines = [];
            let lastSpeaker = 'æ—ç™½'; 

            const saveCurrentBlock = () => {
                if (currentBlockId && currentLines.length > 0) {
                    const block = { lines: [...currentLines] };
                    if (currentBlockType === 'scene') {
                        data.scenes[currentBlockId] = block;
                        if (!data.startSceneId) data.startSceneId = currentBlockId;
                    } else {
                        data.branches[currentBlockId] = block;
                    }
                }
                currentLines = [];
            };

            let i = 0;
            while (i < lines.length) {
                const line = lines[i];

                // 1. Scene Start
                const sceneMatch = line.match(/<SCENE id="([^"]+)">/);
                if (sceneMatch) {
                    saveCurrentBlock();
                    currentBlockId = sceneMatch[1];
                    currentBlockType = 'scene';
                    lastSpeaker = 'æ—ç™½';
                    i++;
                    continue;
                }

                // 2. Branch Start
                const branchMatch = line.match(/<BRANCH from="([^"]+)">/);
                if (branchMatch) {
                    saveCurrentBlock();
                    currentBlockId = branchMatch[1];
                    currentBlockType = 'branch';
                    i++;
                    continue;
                }

                // 3. Choice Block
                if (line.startsWith('<CHOICE')) {
                    const options = [];
                    i++; 
                    while (i < lines.length && !lines[i].startsWith('</CHOICE>')) {
                        const optLine = lines[i];
                        const optMatch = optLine.match(/id="([^"]+)">([^<]+)<\//);
                        if (optMatch) {
                            options.push({ id: optMatch[1], text: optMatch[2] });
                        }
                        i++;
                    }
                    currentLines.push({ type: 'choice', options });
                    i++; 
                    continue;
                }

                // 4. GOTO
                const gotoMatch = line.match(/<GOTO scene="([^"]+)"\s*\/>/);
                if (gotoMatch) {
                    currentLines.push({ type: 'goto', targetScene: gotoMatch[1] });
                    i++;
                    continue;
                }

                // 5. ENDING
                if (line.includes('ã€ç»“å±€')) {
                    const endMatch = line.match(/ã€(.*?)ã€‘\[(.*?)\]\s*[â€”-]+\s*(.*)/);
                    if (endMatch) {
                        currentLines.push({
                            type: 'ending',
                            endingTitle: `ã€${endMatch[1]}ã€‘${endMatch[2]}`,
                            endingEval: endMatch[3]
                        });
                    } else {
                        currentLines.push({
                            type: 'ending',
                            endingTitle: line,
                            endingEval: ''
                        });
                    }
                    i++;
                    continue;
                }
                
                // 6. Closing Tags
                if (line.startsWith('</BRANCH>') || line.startsWith('</ENDING>')) {
                    i++;
                    continue;
                }

                // 7. State
                if (line.startsWith('[') && line.endsWith(']')) {
                    currentLines.push({ 
                        type: 'state', 
                        content: line.slice(1, -1) 
                    });
                    i++;
                    continue;
                }

                // 8. Dialogue
                const colonIndex = line.indexOf(':');
                const zhColonIndex = line.indexOf('ï¼š');
                
                let speaker = lastSpeaker;
                let content = line;

                const splitIndex = (zhColonIndex > -1 && (colonIndex === -1 || zhColonIndex < colonIndex)) ? zhColonIndex : colonIndex;

                if (splitIndex > -1 && splitIndex < 10) { 
                    speaker = line.substring(0, splitIndex).trim();
                    content = line.substring(splitIndex + 1).trim();
                    lastSpeaker = speaker;
                }

                currentLines.push({
                    type: 'dialogue',
                    speaker,
                    content
                });
                i++;
            }
            
            saveCurrentBlock();
            return data;
        };

        // å¤´åƒé¢œè‰²å·¥å…·
        const getAvatarColor = (name) => {
            const colors = [
                'bg-blue-400', 'bg-red-400', 'bg-yellow-400', 'bg-purple-400', 
                'bg-pink-400', 'bg-indigo-400', 'bg-teal-400', 'bg-orange-400'
            ];
            let hash = 0;
            for (let i = 0; i < name.length; i++) hash = name.charCodeAt(i) + ((hash << 5) - hash);
            return colors[Math.abs(hash) % colors.length];
        };

        // å¤´åƒç»„ä»¶
        const Avatar = ({ speaker }) => {
            if (speaker === 'æˆ‘') {
                return (
                    <div className="w-10 h-10 rounded-md bg-gray-200 overflow-hidden flex-shrink-0 border border-gray-300">
                        {/* ä½¿ç”¨ SVG ä½œä¸ºé»˜è®¤å¤´åƒï¼Œç¡®ä¿æ— éœ€å¤–éƒ¨å›¾ç‰‡ */}
                        <svg className="w-full h-full text-gray-400" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M24 20.993V24H0v-2.996A14.977 14.977 0 0112.004 15c4.904 0 9.26 2.354 11.996 5.993zM16.002 8.999a4 4 0 11-8 0 4 4 0 018 0z" />
                        </svg>
                    </div>
                );
            } else if (speaker === 'æ—ç™½') {
                return (
                    <div className="w-10 h-10 rounded-md bg-black flex items-center justify-center flex-shrink-0">
                        <span className="text-white font-bold text-lg">?</span>
                    </div>
                );
            } else {
                return (
                    <div className={`w-10 h-10 rounded-md ${getAvatarColor(speaker)} flex items-center justify-center text-white font-bold text-sm flex-shrink-0`}>
                        {speaker.charAt(0)}
                    </div>
                );
            }
        };

        // --- ä¸»ç¨‹åºç»„ä»¶ ---
        function WeChatFictionReader() {
            // Game Data State
            const [storyData, setStoryData] = useState(null);
            const [messageHistory, setMessageHistory] = useState([]);
            
            // Execution State
            const [currentBlock, setCurrentBlock] = useState([]);
            const [lineIndex, setLineIndex] = useState(0);
            const [waitingForChoice, setWaitingForChoice] = useState(null);
            
            // UI State
            const [isTyping, setIsTyping] = useState(false);
            const [typingSpeaker, setTypingSpeaker] = useState('');
            const [endingInfo, setEndingInfo] = useState(null);
            const [showMenu, setShowMenu] = useState(false);
            
            // Input Handling
            const fileInputRef = useRef(null);
            const chatEndRef = useRef(null);
            const autoPlayTimerRef = useRef(null);
            
            // å…³é”®ä¿®å¤ï¼šä½¿ç”¨ ref æ¥é¿å…é—­åŒ…é™·é˜±
            const processNextLineRef = useRef(() => {});

            const ME = 'æˆ‘';

            // æ»šåŠ¨åˆ°åº•éƒ¨
            useEffect(() => {
                chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [messageHistory, isTyping, waitingForChoice]);

            // åˆå§‹åŒ–
            useEffect(() => {
                setMessageHistory([{
                    id: 0,
                    speaker: 'æ—ç™½',
                    content: 'è¯·ä¸Šä¼ è®°å½•ã€‚',
                    isMe: false,
                    type: 'text'
                }]);
            }, []);

            // æ¸…ç†å®šæ—¶å™¨
            const clearAutoPlay = () => {
                if (autoPlayTimerRef.current) {
                    clearTimeout(autoPlayTimerRef.current);
                    autoPlayTimerRef.current = null;
                }
            };

            // ä¸‹ä¸€è¡Œé€»è¾‘å¤„ç†
            const processNextLine = () => {
                if (!storyData) return;
                if (lineIndex >= currentBlock.length) return; // å—ç»“æŸ
                if (isTyping || waitingForChoice || endingInfo) return; // å¿™ç¢Œä¸­

                const line = currentBlock[lineIndex];

                // é€»è¾‘ç±»å‹ï¼šç«‹å³å¤„ç†
                if (line.type === 'goto') {
                    if (line.targetScene && storyData.scenes[line.targetScene]) {
                        setCurrentBlock(storyData.scenes[line.targetScene].lines);
                        setLineIndex(0);
                        // é€’å½’è°ƒç”¨ä»¥ç«‹å³å¼€å§‹æ–°åœºæ™¯
                        // ä½¿ç”¨ ref é¿å…é—­åŒ…é—®é¢˜
                        setTimeout(() => processNextLineRef.current(), 0); 
                    }
                    return;
                }

                if (line.type === 'choice') {
                    setWaitingForChoice(line.options || []);
                    setLineIndex(prev => prev + 1);
                    return;
                }

                if (line.type === 'ending') {
                    setEndingInfo({
                        title: line.endingTitle || 'ç»“å±€',
                        eval: line.endingEval || 'æš‚æ— è¯„ä»·'
                    });
                    return;
                }

                // å±•ç¤ºç±»å‹ï¼šå¯¹è¯ä¸çŠ¶æ€
                if (line.type === 'dialogue') {
                    setIsTyping(true);
                    setTypingSpeaker(line.speaker || 'æ—ç™½');

                    setTimeout(() => {
                        setIsTyping(false);
                        
                        setMessageHistory(prev => [
                            ...prev,
                            {
                                id: Date.now(),
                                speaker: line.speaker || 'æ—ç™½',
                                content: line.content || '...',
                                isMe: (line.speaker === ME),
                                type: 'text'
                            }
                        ]);

                        setLineIndex(prev => prev + 1);

                        // 3ç§’è‡ªåŠ¨æ’­æ”¾
                        clearAutoPlay();
                        autoPlayTimerRef.current = setTimeout(() => {
                            triggerAutoAdvance();
                        }, 3000);

                    }, 1000);
                } 
                else if (line.type === 'state') {
                    setMessageHistory(prev => [
                        ...prev,
                        {
                            id: Date.now(),
                            speaker: 'System',
                            content: line.content || '',
                            isMe: false,
                            type: 'state'
                        }
                    ]);
                    setLineIndex(prev => prev + 1);
                    // çŠ¶æ€æ˜¾ç¤ºåç«‹å³æ‰§è¡Œä¸‹ä¸€è¡Œ
                    // ä½¿ç”¨ ref.current() ç¡®ä¿è°ƒç”¨çš„æ˜¯æ›´æ–°åçš„å‡½æ•°ç‰ˆæœ¬
                    setTimeout(() => processNextLineRef.current(), 50);
                }
            };

            // ä¿æŒ ref ä¸æœ€æ–°å‡½æ•°åŒæ­¥
            useEffect(() => {
                processNextLineRef.current = processNextLine;
            });

            const triggerAutoAdvance = () => {
                processNextLineRef.current();
            };

            // --- äº¤äº’å¤„ç† ---

            const handleScreenClick = () => {
                clearAutoPlay();
                
                if (!storyData) {
                    fileInputRef.current?.click();
                    return;
                }

                processNextLine();
            };

            const handleChoice = (option) => {
                if (!storyData) return;

                // 1. "æˆ‘" è¯´å‡ºé€‰é¡¹
                setMessageHistory(prev => [
                    ...prev,
                    {
                        id: Date.now(),
                        speaker: ME,
                        content: option.text,
                        isMe: true,
                        type: 'text'
                    }
                ]);

                setWaitingForChoice(null);

                // 2. è·³è½¬åˆ†æ”¯
                const branchBlock = storyData.branches[option.id];
                if (branchBlock) {
                    setCurrentBlock(branchBlock.lines);
                    setLineIndex(0);
                    setTimeout(() => triggerAutoAdvance(), 500);
                } else {
                    console.error(`Branch ${option.id} not found!`);
                }
            };

            const handleFileUpload = (e) => {
                const file = e.target.files?.[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const text = event.target?.result;
                    const parsed = parseScript(text);
                    if (parsed.startSceneId && parsed.scenes[parsed.startSceneId]) {
                        setStoryData(parsed);
                        setCurrentBlock(parsed.scenes[parsed.startSceneId].lines);
                        setLineIndex(0);
                        setMessageHistory([]); 
                        setWaitingForChoice(null);
                        setEndingInfo(null);
                        
                        setTimeout(() => triggerAutoAdvance(), 500);
                    } else {
                        alert("æ— æ³•è§£ææ–‡ä»¶æˆ–æ‰¾ä¸åˆ°èµ·å§‹åœºæ™¯ (id='START' or first scene).");
                    }
                };
                reader.readAsText(file);
            };

            const restartGame = () => {
                if (storyData && storyData.startSceneId) {
                    setCurrentBlock(storyData.scenes[storyData.startSceneId].lines);
                    setLineIndex(0);
                    setMessageHistory([]);
                    setWaitingForChoice(null);
                    setEndingInfo(null);
                    clearAutoPlay();
                    setShowMenu(false);
                    setTimeout(() => triggerAutoAdvance(), 500);
                }
            };

            const resetAll = () => {
                setStoryData(null);
                setMessageHistory([{
                    id: 0,
                    speaker: 'æ—ç™½',
                    content: 'è¯·ä¸Šä¼ è®°å½•ã€‚',
                    isMe: false,
                    type: 'text'
                }]);
                setWaitingForChoice(null);
                setEndingInfo(null);
                clearAutoPlay();
                setShowMenu(false);
            };

            return (
                <div className="flex justify-center items-center w-full h-screen bg-gray-900 font-sans">
                    {/* æ‰‹æœºå®¹å™¨ */}
                    <div className="w-full h-full max-w-md bg-[#F5F5F5] flex flex-col relative overflow-hidden shadow-2xl">
                        
                        {/* é¡¶éƒ¨æ  */}
                        <header className="bg-[#EDEDED] h-12 flex items-center justify-between px-4 border-b border-gray-300 z-20 shrink-0 select-none">
                            <div className="flex items-center space-x-1">
                                <svg width="12" height="20" viewBox="0 0 12 20" fill="none">
                                    <path d="M10 2L2 10L10 18" stroke="black" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                                </svg>
                                <span className="font-medium text-lg ml-2">äº’åŠ¨å°è¯´é˜…è¯»å™¨</span>
                            </div>
                            <button onClick={() => setShowMenu(!showMenu)} className="p-2 rounded-md hover:bg-gray-200">
                                <MoreHorizontal className="text-black" />
                            </button>
                        </header>

                        {/* èœå• */}
                        {showMenu && (
                            <div className="absolute top-12 right-2 bg-[#4C4C4C] rounded-lg shadow-xl z-50 py-2 w-40 text-white animate-in slide-in-from-top-2">
                                <button onClick={restartGame} className="flex items-center px-4 py-3 w-full hover:bg-[#5C5C5C] border-b border-[#5C5C5C]">
                                    <RotateCcw size={18} className="mr-3" />
                                    é‡æ–°å¼€å§‹
                                </button>
                                <button onClick={() => { fileInputRef.current?.click(); setShowMenu(false); }} className="flex items-center px-4 py-3 w-full hover:bg-[#5C5C5C]">
                                    <Upload size={18} className="mr-3" />
                                    ä¸Šä¼ æ–°çºªå½•
                                </button>
                            </div>
                        )}

                        {/* èŠå¤©åŒºåŸŸ */}
                        <div 
                            className="flex-1 overflow-y-auto p-4 space-y-4 no-scrollbar" 
                            onClick={handleScreenClick}
                        >
                            {messageHistory.map((msg) => {
                                if (msg.type === 'state') {
                                    return (
                                        <div key={msg.id} className="flex justify-center py-2">
                                            <span className="bg-[#DADADA] text-white text-xs px-2 py-1 rounded-sm">
                                                {msg.content}
                                            </span>
                                        </div>
                                    );
                                }

                                return (
                                    <div key={msg.id} className={`flex w-full mb-4 ${msg.isMe ? 'justify-end' : 'justify-start'}`}>
                                        {!msg.isMe && <Avatar speaker={msg.speaker} />}
                                        
                                        <div className={`mx-2 max-w-[70%] relative`}>
                                            {!msg.isMe && msg.speaker !== 'æ—ç™½' && (
                                                <p className="text-gray-500 text-xs mb-1 ml-1">{msg.speaker}</p>
                                            )}
                                            
                                            <div className={`px-3 py-2 rounded-lg text-black text-[15px] leading-relaxed break-words relative 
                                                ${msg.isMe ? 'bg-[#95ec69]' : 'bg-white'} 
                                                ${msg.isMe ? 'rounded-tr-none' : 'rounded-tl-none'}
                                                shadow-sm border border-gray-200/50`}>
                                                
                                                {/* æ°”æ³¡ç®­å¤´ */}
                                                <div className={`absolute top-[6px] w-2 h-2 transform rotate-45 
                                                    ${msg.isMe ? '-right-1 bg-[#95ec69]' : '-left-1 bg-white'}
                                                `}></div>
                                                
                                                {msg.content}
                                            </div>
                                        </div>

                                        {msg.isMe && <Avatar speaker={msg.speaker} />}
                                    </div>
                                );
                            })}

                            {/* è¾“å…¥ä¸­æŒ‡ç¤ºå™¨ */}
                            {isTyping && (
                                <div className={`flex w-full mb-4 justify-start`}>
                                    <Avatar speaker={typingSpeaker} />
                                    <div className="mx-2 bg-white px-4 py-3 rounded-lg rounded-tl-none shadow-sm flex items-center space-x-1 h-[40px]">
                                        <div className="w-1.5 h-1.5 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></div>
                                        <div className="w-1.5 h-1.5 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></div>
                                        <div className="w-1.5 h-1.5 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></div>
                                    </div>
                                </div>
                            )}

                            <div ref={chatEndRef} className="h-4" />
                        </div>

                        {/* åº•éƒ¨è¾“å…¥/é€‰é¡¹åŒºåŸŸ */}
                        <div className="bg-[#F7F7F7] border-t border-[#DCDCDC] p-2 min-h-[50px] shrink-0 flex items-center justify-center safe-area-pb">
                            {waitingForChoice ? (
                                <div className="w-full flex flex-col space-y-2 p-1">
                                    {waitingForChoice.map((option) => (
                                        <button
                                            key={option.id}
                                            onClick={(e) => { e.stopPropagation(); handleChoice(option); }}
                                            className="w-full bg-white active:bg-gray-100 text-black py-3 rounded-md border border-gray-200 text-sm font-medium shadow-sm transition-colors"
                                        >
                                            {option.text}
                                        </button>
                                    ))}
                                </div>
                            ) : (
                                <div 
                                    className="w-full bg-white h-10 rounded-md border border-[#DCDCDC] flex items-center justify-center text-gray-400 text-sm active:bg-gray-50 select-none cursor-pointer"
                                    onClick={handleScreenClick}
                                >
                                    {!storyData ? "ç‚¹å‡»æ­¤å¤„ä¸Šä¼ å‰§æƒ…æ–‡ä»¶" : "ç‚¹å‡»å±å¹•ç»§ç»­..."}
                                </div>
                            )}
                        </div>

                        {/* éšè—çš„æ–‡ä»¶è¾“å…¥æ¡† */}
                        <input
                            type="file"
                            accept=".csv,.txt,.xml"
                            ref={fileInputRef}
                            className="hidden"
                            onChange={handleFileUpload}
                        />

                        {/* ç»“å±€å¼¹çª— */}
                        {endingInfo && (
                            <div className="absolute inset-0 z-50 bg-black/50 backdrop-blur-sm flex items-center justify-center p-6 animate-in">
                                <div className="bg-white w-full rounded-xl shadow-2xl overflow-hidden zoom-in-95">
                                    <div className="bg-[#EDEDED] px-6 py-4 border-b border-gray-200">
                                        <h2 className="text-xl font-bold text-center text-gray-800">{endingInfo.title}</h2>
                                    </div>
                                    <div className="p-8 text-center">
                                        <div className="text-6xl mb-4">ğŸ</div>
                                        <p className="text-gray-600 text-lg leading-relaxed">{endingInfo.eval}</p>
                                    </div>
                                    <div className="bg-[#F7F7F7] p-4 flex flex-col gap-3">
                                        <button 
                                            onClick={restartGame}
                                            className="w-full bg-[#07C160] hover:bg-[#06ad56] text-white font-medium py-3 rounded-lg transition-colors"
                                        >
                                            é‡æ–°æ¸¸ç©
                                        </button>
                                        <button 
                                            onClick={() => { resetAll(); fileInputRef.current?.click(); }}
                                            className="w-full bg-white hover:bg-gray-50 text-gray-800 font-medium py-3 rounded-lg border border-gray-300 transition-colors"
                                        >
                                            ä¸Šä¼ æ–°çºªå½•
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}

                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<WeChatFictionReader />);
    </script>
</body>
</html>
