<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>互动小说阅读器</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* 自定义样式 */
        body, html {
            overscroll-behavior: none; /* 防止移动端下拉刷新 */
        }
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .safe-area-pb {
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        /* 动画关键帧模拟 */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .animate-in {
            animation: fadeIn 0.2s ease-out forwards;
        }
        @keyframes slideInFromTop {
            from { transform: translateY(-0.5rem); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .slide-in-from-top-2 {
            animation: slideInFromTop 0.2s ease-out forwards;
        }
        @keyframes zoomIn {
            from { transform: scale(0.95); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        .zoom-in-95 {
            animation: zoomIn 0.2s ease-out forwards;
        }
    </style>
</head>
<body class="bg-gray-900 text-base antialiased">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- 图标组件 (替换 lucide-react) ---
        const MoreHorizontal = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/></svg>
        );
        const RotateCcw = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"/><path d="M3 3v9h9"/></svg>
        );
        const Upload = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
        );

        // --- 核心逻辑 ---

        // 解析脚本工具函数
        const parseScript = (text) => {
            const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l);
            const data = { scenes: {}, branches: {}, startSceneId: null };
            
            let currentBlockId = null;
            let currentBlockType = null; // 'scene' | 'branch'
            let currentLines = [];
            let lastSpeaker = '旁白'; 

            const saveCurrentBlock = () => {
                if (currentBlockId && currentLines.length > 0) {
                    const block = { lines: [...currentLines] };
                    if (currentBlockType === 'scene') {
                        data.scenes[currentBlockId] = block;
                        if (!data.startSceneId) data.startSceneId = currentBlockId;
                    } else {
                        data.branches[currentBlockId] = block;
                    }
                }
                currentLines = [];
            };

            let i = 0;
            while (i < lines.length) {
                const line = lines[i];

                // 1. Scene Start
                const sceneMatch = line.match(/<SCENE id="([^"]+)">/);
                if (sceneMatch) {
                    saveCurrentBlock();
                    currentBlockId = sceneMatch[1];
                    currentBlockType = 'scene';
                    lastSpeaker = '旁白';
                    i++;
                    continue;
                }

                // 2. Branch Start
                const branchMatch = line.match(/<BRANCH from="([^"]+)">/);
                if (branchMatch) {
                    saveCurrentBlock();
                    currentBlockId = branchMatch[1];
                    currentBlockType = 'branch';
                    i++;
                    continue;
                }

                // 3. Choice Block
                if (line.startsWith('<CHOICE')) {
                    const options = [];
                    i++; 
                    while (i < lines.length && !lines[i].startsWith('</CHOICE>')) {
                        const optLine = lines[i];
                        const optMatch = optLine.match(/id="([^"]+)">([^<]+)<\//);
                        if (optMatch) {
                            options.push({ id: optMatch[1], text: optMatch[2] });
                        }
                        i++;
                    }
                    currentLines.push({ type: 'choice', options });
                    i++; 
                    continue;
                }

                // 4. GOTO
                const gotoMatch = line.match(/<GOTO scene="([^"]+)"\s*\/>/);
                if (gotoMatch) {
                    currentLines.push({ type: 'goto', targetScene: gotoMatch[1] });
                    i++;
                    continue;
                }

                // 5. ENDING
                if (line.includes('【结局')) {
                    const endMatch = line.match(/【(.*?)】\[(.*?)\]\s*[—-]+\s*(.*)/);
                    if (endMatch) {
                        currentLines.push({
                            type: 'ending',
                            endingTitle: `【${endMatch[1]}】${endMatch[2]}`,
                            endingEval: endMatch[3]
                        });
                    } else {
                        currentLines.push({
                            type: 'ending',
                            endingTitle: line,
                            endingEval: ''
                        });
                    }
                    i++;
                    continue;
                }
                
                // 6. Closing Tags
                if (line.startsWith('</BRANCH>') || line.startsWith('</ENDING>')) {
                    i++;
                    continue;
                }

                // 7. State
                if (line.startsWith('[') && line.endsWith(']')) {
                    currentLines.push({ 
                        type: 'state', 
                        content: line.slice(1, -1) 
                    });
                    i++;
                    continue;
                }

                // 8. Dialogue
                const colonIndex = line.indexOf(':');
                const zhColonIndex = line.indexOf('：');
                
                let speaker = lastSpeaker;
                let content = line;

                const splitIndex = (zhColonIndex > -1 && (colonIndex === -1 || zhColonIndex < colonIndex)) ? zhColonIndex : colonIndex;

                if (splitIndex > -1 && splitIndex < 10) { 
                    speaker = line.substring(0, splitIndex).trim();
                    content = line.substring(splitIndex + 1).trim();
                    lastSpeaker = speaker;
                }

                currentLines.push({
                    type: 'dialogue',
                    speaker,
                    content
                });
                i++;
            }
            
            saveCurrentBlock();
            return data;
        };

        // 头像颜色工具
        const getAvatarColor = (name) => {
            const colors = [
                'bg-blue-400', 'bg-red-400', 'bg-yellow-400', 'bg-purple-400', 
                'bg-pink-400', 'bg-indigo-400', 'bg-teal-400', 'bg-orange-400'
            ];
            let hash = 0;
            for (let i = 0; i < name.length; i++) hash = name.charCodeAt(i) + ((hash << 5) - hash);
            return colors[Math.abs(hash) % colors.length];
        };

        // 头像组件
        const Avatar = ({ speaker }) => {
            if (speaker === '我') {
                return (
                    <div className="w-10 h-10 rounded-md bg-gray-200 overflow-hidden flex-shrink-0 border border-gray-300">
                        {/* 使用 SVG 作为默认头像，确保无需外部图片 */}
                        <svg className="w-full h-full text-gray-400" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M24 20.993V24H0v-2.996A14.977 14.977 0 0112.004 15c4.904 0 9.26 2.354 11.996 5.993zM16.002 8.999a4 4 0 11-8 0 4 4 0 018 0z" />
                        </svg>
                    </div>
                );
            } else if (speaker === '旁白') {
                return (
                    <div className="w-10 h-10 rounded-md bg-black flex items-center justify-center flex-shrink-0">
                        <span className="text-white font-bold text-lg">?</span>
                    </div>
                );
            } else {
                return (
                    <div className={`w-10 h-10 rounded-md ${getAvatarColor(speaker)} flex items-center justify-center text-white font-bold text-sm flex-shrink-0`}>
                        {speaker.charAt(0)}
                    </div>
                );
            }
        };

        // --- 主程序组件 ---
        function WeChatFictionReader() {
            // Game Data State
            const [storyData, setStoryData] = useState(null);
            const [messageHistory, setMessageHistory] = useState([]);
            
            // Execution State
            const [currentBlock, setCurrentBlock] = useState([]);
            const [lineIndex, setLineIndex] = useState(0);
            const [waitingForChoice, setWaitingForChoice] = useState(null);
            // 新增：记录上一个选择点的状态
            const [lastChoicePoint, setLastChoicePoint] = useState(null);
            
            // UI State
            const [isTyping, setIsTyping] = useState(false);
            const [typingSpeaker, setTypingSpeaker] = useState('');
            const [endingInfo, setEndingInfo] = useState(null);
            const [showMenu, setShowMenu] = useState(false);
            
            // Input Handling
            const fileInputRef = useRef(null);
            const chatEndRef = useRef(null);
            const autoPlayTimerRef = useRef(null);
            
            // 关键修复：使用 ref 来避免闭包陷阱
            const processNextLineRef = useRef(() => {});

            const ME = '我';

            // 滚动到底部
            useEffect(() => {
                chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [messageHistory, isTyping, waitingForChoice]);

            // 初始化
            useEffect(() => {
                setMessageHistory([{
                    id: 0,
                    speaker: '旁白',
                    content: '请上传记录。',
                    isMe: false,
                    type: 'text'
                }]);
            }, []);

            // 清理定时器
            const clearAutoPlay = () => {
                if (autoPlayTimerRef.current) {
                    clearTimeout(autoPlayTimerRef.current);
                    autoPlayTimerRef.current = null;
                }
            };

            // 下一行逻辑处理
            const processNextLine = () => {
                if (!storyData) return;
                if (lineIndex >= currentBlock.length) return; // 块结束
                if (isTyping || waitingForChoice || endingInfo) return; // 忙碌中

                const line = currentBlock[lineIndex];

                // 逻辑类型：立即处理
                if (line.type === 'goto') {
                    if (line.targetScene && storyData.scenes[line.targetScene]) {
                        setCurrentBlock(storyData.scenes[line.targetScene].lines);
                        setLineIndex(0);
                        // 递归调用以立即开始新场景
                        // 使用 ref 避免闭包问题
                        setTimeout(() => processNextLineRef.current(), 0); 
                    }
                    return;
                }

                if (line.type === 'choice') {
                    setWaitingForChoice(line.options || []);
                    setLineIndex(prev => prev + 1);
                    return;
                }

                if (line.type === 'ending') {
                    setEndingInfo({
                        title: line.endingTitle || '结局',
                        eval: line.endingEval || '暂无评价'
                    });
                    return;
                }

                // 展示类型：对话与状态
                if (line.type === 'dialogue') {
                    setIsTyping(true);
                    setTypingSpeaker(line.speaker || '旁白');

                    setTimeout(() => {
                        setIsTyping(false);
                        
                        setMessageHistory(prev => [
                            ...prev,
                            {
                                id: Date.now(),
                                speaker: line.speaker || '旁白',
                                content: line.content || '...',
                                isMe: (line.speaker === ME),
                                type: 'text'
                            }
                        ]);

                        setLineIndex(prev => prev + 1);

                        // 3秒自动播放
                        clearAutoPlay();
                        autoPlayTimerRef.current = setTimeout(() => {
                            triggerAutoAdvance();
                        }, 3000);

                    }, 1000);
                } 
                else if (line.type === 'state') {
                    setMessageHistory(prev => [
                        ...prev,
                        {
                            id: Date.now(),
                            speaker: 'System',
                            content: line.content || '',
                            isMe: false,
                            type: 'state'
                        }
                    ]);
                    setLineIndex(prev => prev + 1);
                    // 状态显示后立即执行下一行
                    // 使用 ref.current() 确保调用的是更新后的函数版本
                    setTimeout(() => processNextLineRef.current(), 50);
                }
            };

            // 保持 ref 与最新函数同步
            useEffect(() => {
                processNextLineRef.current = processNextLine;
            });

            const triggerAutoAdvance = () => {
                processNextLineRef.current();
            };

            // --- 交互处理 ---

            const handleScreenClick = () => {
                clearAutoPlay();
                
                if (!storyData) {
                    fileInputRef.current?.click();
                    return;
                }

                processNextLine();
            };

            const handleChoice = (option) => {
                if (!storyData) return;

                // 1. 保存当前状态作为“上一个选择点”
                setLastChoicePoint({
                    messageHistory: [...messageHistory],
                    choices: waitingForChoice
                });

                // 2. "我" 说出选项
                setMessageHistory(prev => [
                    ...prev,
                    {
                        id: Date.now(),
                        speaker: ME,
                        content: option.text,
                        isMe: true,
                        type: 'text'
                    }
                ]);

                setWaitingForChoice(null);

                // 3. 跳转分支
                const branchBlock = storyData.branches[option.id];
                if (branchBlock) {
                    setCurrentBlock(branchBlock.lines);
                    setLineIndex(0);
                    setTimeout(() => triggerAutoAdvance(), 500);
                } else {
                    console.error(`Branch ${option.id} not found!`);
                }
            };

            // 新增：处理回到上一个选择点
            const handleBackToChoice = () => {
                if (lastChoicePoint) {
                    setMessageHistory(lastChoicePoint.messageHistory);
                    setWaitingForChoice(lastChoicePoint.choices);
                    setEndingInfo(null);
                    setCurrentBlock([]); // 清空当前块，停止自动播放逻辑
                    setLineIndex(0);
                    clearAutoPlay();
                }
            };

            const handleFileUpload = (e) => {
                const file = e.target.files?.[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const text = event.target?.result;
                    const parsed = parseScript(text);
                    if (parsed.startSceneId && parsed.scenes[parsed.startSceneId]) {
                        setStoryData(parsed);
                        setCurrentBlock(parsed.scenes[parsed.startSceneId].lines);
                        setLineIndex(0);
                        setMessageHistory([]); 
                        setWaitingForChoice(null);
                        setEndingInfo(null);
                        setLastChoicePoint(null); // 重置历史点
                        
                        setTimeout(() => triggerAutoAdvance(), 500);
                    } else {
                        alert("无法解析文件或找不到起始场景 (id='START' or first scene).");
                    }
                };
                reader.readAsText(file);
            };

            const restartGame = () => {
                if (storyData && storyData.startSceneId) {
                    setCurrentBlock(storyData.scenes[storyData.startSceneId].lines);
                    setLineIndex(0);
                    setMessageHistory([]);
                    setWaitingForChoice(null);
                    setEndingInfo(null);
                    setLastChoicePoint(null);
                    clearAutoPlay();
                    setShowMenu(false);
                    setTimeout(() => triggerAutoAdvance(), 500);
                }
            };

            const resetAll = () => {
                setStoryData(null);
                setMessageHistory([{
                    id: 0,
                    speaker: '旁白',
                    content: '请上传记录。',
                    isMe: false,
                    type: 'text'
                }]);
                setWaitingForChoice(null);
                setEndingInfo(null);
                setLastChoicePoint(null);
                clearAutoPlay();
                setShowMenu(false);
            };

            return (
                <div className="flex justify-center items-center w-full h-screen bg-gray-900 font-sans">
                    {/* 手机容器 */}
                    <div className="w-full h-full max-w-md bg-[#F5F5F5] flex flex-col relative overflow-hidden shadow-2xl">
                        
                        {/* 顶部栏 */}
                        <header className="bg-[#EDEDED] h-12 flex items-center justify-between px-4 border-b border-gray-300 z-20 shrink-0 select-none">
                            <div className="flex items-center space-x-1">
                                <svg width="12" height="20" viewBox="0 0 12 20" fill="none">
                                    <path d="M10 2L2 10L10 18" stroke="black" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                                </svg>
                                <span className="font-medium text-lg ml-2">互动小说阅读器</span>
                            </div>
                            <button onClick={() => setShowMenu(!showMenu)} className="p-2 rounded-md hover:bg-gray-200">
                                <MoreHorizontal className="text-black" />
                            </button>
                        </header>

                        {/* 菜单 */}
                        {showMenu && (
                            <div className="absolute top-12 right-2 bg-[#4C4C4C] rounded-lg shadow-xl z-50 py-2 w-40 text-white animate-in slide-in-from-top-2">
                                <button onClick={restartGame} className="flex items-center px-4 py-3 w-full hover:bg-[#5C5C5C] border-b border-[#5C5C5C]">
                                    <RotateCcw size={18} className="mr-3" />
                                    重新开始
                                </button>
                                <button onClick={() => { fileInputRef.current?.click(); setShowMenu(false); }} className="flex items-center px-4 py-3 w-full hover:bg-[#5C5C5C]">
                                    <Upload size={18} className="mr-3" />
                                    上传新纪录
                                </button>
                            </div>
                        )}

                        {/* 聊天区域 */}
                        <div 
                            className="flex-1 overflow-y-auto p-4 space-y-4 no-scrollbar" 
                            onClick={handleScreenClick}
                        >
                            {messageHistory.map((msg) => {
                                if (msg.type === 'state') {
                                    return (
                                        <div key={msg.id} className="flex justify-center py-2">
                                            <span className="bg-[#DADADA] text-white text-xs px-2 py-1 rounded-sm">
                                                {msg.content}
                                            </span>
                                        </div>
                                    );
                                }

                                return (
                                    <div key={msg.id} className={`flex w-full mb-4 ${msg.isMe ? 'justify-end' : 'justify-start'}`}>
                                        {!msg.isMe && <Avatar speaker={msg.speaker} />}
                                        
                                        <div className={`mx-2 max-w-[70%] relative`}>
                                            {!msg.isMe && msg.speaker !== '旁白' && (
                                                <p className="text-gray-500 text-xs mb-1 ml-1">{msg.speaker}</p>
                                            )}
                                            
                                            <div className={`px-3 py-2 rounded-lg text-black text-[15px] leading-relaxed break-words relative 
                                                ${msg.isMe ? 'bg-[#95ec69]' : 'bg-white'} 
                                                ${msg.isMe ? 'rounded-tr-none' : 'rounded-tl-none'}
                                                shadow-sm border border-gray-200/50`}>
                                                
                                                {/* 气泡箭头 */}
                                                <div className={`absolute top-[6px] w-2 h-2 transform rotate-45 
                                                    ${msg.isMe ? '-right-1 bg-[#95ec69]' : '-left-1 bg-white'}
                                                `}></div>
                                                
                                                {msg.content}
                                            </div>
                                        </div>

                                        {msg.isMe && <Avatar speaker={msg.speaker} />}
                                    </div>
                                );
                            })}

                            {/* 输入中指示器 */}
                            {isTyping && (
                                <div className={`flex w-full mb-4 justify-start`}>
                                    <Avatar speaker={typingSpeaker} />
                                    <div className="mx-2 bg-white px-4 py-3 rounded-lg rounded-tl-none shadow-sm flex items-center space-x-1 h-[40px]">
                                        <div className="w-1.5 h-1.5 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></div>
                                        <div className="w-1.5 h-1.5 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></div>
                                        <div className="w-1.5 h-1.5 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></div>
                                    </div>
                                </div>
                            )}

                            <div ref={chatEndRef} className="h-4" />
                        </div>

                        {/* 底部输入/选项区域 */}
                        <div className="bg-[#F7F7F7] border-t border-[#DCDCDC] p-2 min-h-[50px] shrink-0 flex items-center justify-center safe-area-pb">
                            {waitingForChoice ? (
                                <div className="w-full flex flex-col space-y-2 p-1">
                                    {waitingForChoice.map((option) => (
                                        <button
                                            key={option.id}
                                            onClick={(e) => { e.stopPropagation(); handleChoice(option); }}
                                            className="w-full bg-white active:bg-gray-100 text-black py-3 rounded-md border border-gray-200 text-sm font-medium shadow-sm transition-colors"
                                        >
                                            {option.text}
                                        </button>
                                    ))}
                                </div>
                            ) : (
                                <div 
                                    className="w-full bg-white h-10 rounded-md border border-[#DCDCDC] flex items-center justify-center text-gray-400 text-sm active:bg-gray-50 select-none cursor-pointer"
                                    onClick={handleScreenClick}
                                >
                                    {!storyData ? "点击此处上传剧情文件" : "点击屏幕继续..."}
                                </div>
                            )}
                        </div>

                        {/* 隐藏的文件输入框 */}
                        <input
                            type="file"
                            accept=".csv,.txt,.xml"
                            ref={fileInputRef}
                            className="hidden"
                            onChange={handleFileUpload}
                        />

                        {/* 结局弹窗 - Apple News 风格优化版 */}
                        {endingInfo && (
                            <div className="absolute inset-0 z-50 bg-gray-900/40 backdrop-blur-md flex items-center justify-center p-6 animate-in">
                                <div className="bg-white w-full max-w-sm rounded-2xl shadow-2xl overflow-hidden zoom-in-95 border border-gray-100">
                                    <div className="px-8 pt-10 pb-6 text-center">
                                        <p className="text-xs font-bold tracking-widest text-[#FF2D55] uppercase mb-3">
                                            The End
                                        </p>
                                        <h2 className="text-3xl font-serif font-bold text-gray-900 leading-tight mb-4">
                                            {endingInfo.title}
                                        </h2>
                                        <div className="w-12 h-1 bg-gray-100 mx-auto mb-6"></div>
                                        <p className="text-gray-500 font-sans text-lg leading-relaxed">
                                            {endingInfo.eval}
                                        </p>
                                    </div>

                                    <div className="p-6 pt-0 flex flex-col gap-3">
                                        <button 
                                            onClick={restartGame}
                                            className="w-full bg-black hover:bg-gray-800 text-white font-semibold py-3.5 rounded-xl transition-all shadow-lg shadow-gray-200"
                                        >
                                            重新游玩
                                        </button>
                                        
                                        {/* 新增：回到上一个选择点 */}
                                        {lastChoicePoint && (
                                            <button 
                                                onClick={handleBackToChoice}
                                                className="w-full bg-gray-100 hover:bg-gray-200 text-gray-900 font-semibold py-3.5 rounded-xl transition-colors"
                                            >
                                                回到上一个选择点
                                            </button>
                                        )}

                                        <button 
                                            onClick={() => { resetAll(); fileInputRef.current?.click(); }}
                                            className="w-full bg-gray-100 hover:bg-gray-200 text-gray-900 font-semibold py-3.5 rounded-xl transition-colors"
                                        >
                                            上传新纪录
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}

                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<WeChatFictionReader />);
    </script>
</body>
</html>
